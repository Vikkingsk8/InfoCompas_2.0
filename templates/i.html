<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ИнфоКомпас</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
    <link rel="icon" href="{{ url_for('static', filename='icon.png') }}">
</head>
<body>
    <div class="header">
        <img src="{{ url_for('static', filename='image.png') }}" alt="Логотип ЦБ РФ" class="logo">
    </div>
    <div class="main-container">
        <div id="pdf-container" style="display: none;">
            <div id="pdf-pages"></div>
        </div>
        <div class="chat-container">  
            <div id="chat-messages"></div>
            <div id="buttons-container"></div>
            <div class="chat-box" id="chat-box">
                <!-- Здесь будет отображаться диалог -->
            </div>
            <div class="input-container">
                <div id="suggestion-box" class="suggestion-box"></div>
                <input type="text" class="input-field" id="input-field" placeholder="Введите ваш запрос...">
                <button class="send-button" id="send-button">Отправить</button>
                <button id="toggle-instruction" class="toggle-button">Показать руководство</button>
            </div>
        </div>
    </div>
    <div class="footer">
        <div class="contact-info">
            <div>Управление развития электронного взаимодействия</div>
        </div>    
        <div class="email">
            <div>lk_uio@cbr.ru</div>
        </div>
        <div class="copyright">© 2024 Внешний портал Банка России 2000 - 2024</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
<script>
    const chatBox = document.getElementById('chat-box');
    const inputField = document.getElementById('input-field');
    const sendButton = document.getElementById('send-button');
    const suggestionBox = document.getElementById('suggestion-box');
    const toggleInstructionButton = document.getElementById('toggle-instruction');
    const pdfContainer = document.getElementById('pdf-container');
    const pdfPagesContainer = document.getElementById('pdf-pages');

    const links = [
        { type: 'fork', question: 'Fork Question 1' },
        { type: 'pdf', question: 'PDF Question 1' },
        { type: 'link', question: 'Link Question 1' },
    ];

    let lastQuestion = '';
    let previousAnswers = [];
    let suggestions = [];
    let pdfDoc = null;
    let currentPage = 1;
    let renderedPages = [];

    // Приветствие при запуске
    function showWelcomeMessage() {
        const welcomeMessage = "Привет! Я ИнфоКомпас, ваш виртуальный помощник. Чем могу помочь?";
        prependMessage(welcomeMessage, 'bot-message', '{{ url_for('static', filename='bot_icon.png') }}');
        
        // Создаем контейнер для кнопок с начальными вопросами
        const buttonsContainer = document.createElement('div');
        buttonsContainer.classList.add('initial-questions-container');
        
        // Добавляем кнопки с начальными вопросами
        {{ initial_questions | tojson }}.forEach(question => {
            const button = document.createElement('button');
            button.textContent = question;
            button.classList.add('initial-question-btn');
            button.addEventListener('click', () => {
                inputField.value = question;
                sendMessage();
            });
            buttonsContainer.appendChild(button);
        });
        
        // Добавляем контейнер с кнопками в начало чат-бокса
        chatBox.insertBefore(buttonsContainer, chatBox.firstChild);
    }

    // Вызываем функцию приветствия при загрузке страницы
    showWelcomeMessage();
    // Загрузка предложений для автодополнения
    async function loadSuggestions() {
        const response = await fetch('/load_suggestions');
        const data = await response.json();
        suggestions = data.suggestions;
    }

    // Отображение автодополнения
    function showSuggestion(query) {
        suggestionBox.innerHTML = '';
        if (query.length > 0) {
            const matchedSuggestion = suggestions.find(suggestion => suggestion.toLowerCase().includes(query.toLowerCase()));
            if (matchedSuggestion) {
                const suggestionButton = document.createElement('button');
                suggestionButton.textContent = matchedSuggestion;
                suggestionButton.classList.add('suggestion-button');
                suggestionButton.addEventListener('click', () => {
                    inputField.value = matchedSuggestion;
                    suggestionBox.innerHTML = '';
                    suggestionBox.classList.remove('show');
                });
                suggestionBox.appendChild(suggestionButton);
                suggestionBox.classList.add('show');
            } else {
                suggestionBox.classList.remove('show');
            }
        } else {
            suggestionBox.classList.remove('show');
        }
    }

    inputField.addEventListener('input', () => showSuggestion(inputField.value));

    sendButton.addEventListener('click', sendMessage);

    inputField.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') sendMessage();
    });

    document.addEventListener('DOMContentLoaded', function() {
        const toggleInstructionButton = document.getElementById('toggle-instruction');
        const pdfContainer = document.getElementById('pdf-container');
        const mainContainer = document.querySelector('.main-container');
    
        toggleInstructionButton.addEventListener('click', () => {
            pdfContainer.classList.toggle('visible');
            mainContainer.classList.toggle('split');
            
            if (pdfContainer.classList.contains('visible')) {
                toggleInstructionButton.textContent = 'Скрыть руководство';
                renderAllPages(); // Рендерим первые три страницы при отображении
            } else {
                toggleInstructionButton.textContent = 'Показать руководство';
            }
        });
    });

    document.addEventListener('DOMContentLoaded', function() {
        var url = '/static/instruction.pdf';
        var pdfjsLib = window['pdfjs-dist/build/pdf'];
    
        pdfjsLib.getDocument(url).promise.then(function(pdf) {
            pdfDoc = pdf;
            setupScrollListener();
        });
    });

    function renderAllPages() {
        pdfPagesContainer.innerHTML = '';
        const startPage = 1;
        const endPage = Math.min(3, pdfDoc.numPages);
        for (let i = startPage; i <= endPage; i++) {
            renderPage(i);
        }
    }

    function renderPage(pageNumber) {
        if (renderedPages.includes(pageNumber)) return;
        renderedPages.push(pageNumber);

        pdfDoc.getPage(pageNumber).then(function(page) {
            var scale = 1.5;
            var viewport = page.getViewport({scale: scale});

            var canvas = document.createElement('canvas');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            var context = canvas.getContext('2d');

            var renderContext = {
                canvasContext: context,
                viewport: viewport
            };

            var pageContainer = document.createElement('div');
            pageContainer.classList.add('pdf-page-container');
            pageContainer.setAttribute('data-page', pageNumber);
            pageContainer.appendChild(canvas);
            pdfPagesContainer.appendChild(pageContainer);

            page.render(renderContext).promise.then(function() {
                return page.getTextContent();
            }).then(function(textContent) {
                var textLayer = document.createElement('div');
                textLayer.classList.add('textLayer');
                pageContainer.appendChild(textLayer);

                pdfjsLib.renderTextLayer({
                    textContent: textContent,
                    container: textLayer,
                    viewport: viewport,
                    textDivs: []
                });
            });
        });
    }

    function setupScrollListener() {
        pdfContainer.addEventListener('scroll', () => {
            const scrollTop = pdfContainer.scrollTop;
            const scrollHeight = pdfContainer.scrollHeight;
            const clientHeight = pdfContainer.clientHeight;

            if (scrollTop + clientHeight >= scrollHeight - 10) {
                // Если прокрутка достигла конца, рендерим следующие три страницы
                const currentLastPage = renderedPages[renderedPages.length - 1];
                const endPage = Math.min(currentLastPage + 3, pdfDoc.numPages);
                for (let i = currentLastPage + 1; i <= endPage; i++) {
                    renderPage(i);
                }
                // Удаляем первую страницу, если она больше не нужна
                if (renderedPages.length > 3) {
                    const firstPage = renderedPages.shift();
                    const firstPageElement = pdfPagesContainer.querySelector(`[data-page="${firstPage}"]`);
                    if (firstPageElement) firstPageElement.remove();
                }
            } else if (scrollTop <= 10 && currentPage > 1) {
                // Если прокрутка достигла начала, рендерим предыдущие три страницы
                const currentFirstPage = renderedPages[0];
                const startPage = Math.max(1, currentFirstPage - 3);
                for (let i = startPage; i < currentFirstPage; i++) {
                    renderPage(i);
                }
                // Удаляем последнюю страницу, если она больше не нужна
                if (renderedPages.length > 3) {
                    const lastPage = renderedPages.pop();
                    const lastPageElement = pdfPagesContainer.querySelector(`[data-page="${lastPage}"]`);
                    if (lastPageElement) lastPageElement.remove();
                }
            }
        });
    }

    toggleInstructionButton.addEventListener('click', () => {
        const pdfContainer = document.getElementById('pdf-container');
        const mainContainer = document.querySelector('.main-container');
        
        if (pdfContainer.style.display === 'none') {
            pdfContainer.style.display = 'block';
            mainContainer.classList.add('split');
            toggleInstructionButton.textContent = 'Скрыть руководство';
        } else {
            pdfContainer.style.display = 'none';
            mainContainer.classList.remove('split');
            toggleInstructionButton.textContent = 'Показать руководство';
        }
    });

    async function sendMessage(message = null) {
        console.log("sendMessage вызвана");
        const userMessage = message || inputField.value.trim();
        if (userMessage !== '') {
            lastQuestion = userMessage;
            prependMessage(userMessage, 'user-message', '{{ url_for('static', filename='user_icon.png') }}');
            inputField.value = '';
            suggestionBox.innerHTML = '';
    
            const loadingMessage = prependMessage('Генерация ответа...', 'loading-message');
    
            try {
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ question: userMessage, previous_answers: previousAnswers })
                });
    
                const data = await response.json();
                loadingMessage.remove();
    
                const messageElement = prependMessage(data.answer, 'bot-message', '{{ url_for('static', filename='bot_icon.png') }}', data.images, data.pdf_page);
    
                clearLinksContainer();
    
                if (data.links && data.links.length > 0) {
                    const newLinksContainer = createLinksContainer(data.links, userMessage);
                    chatBox.insertBefore(newLinksContainer, chatBox.firstChild);
                }
    
                clearButtonsContainer();
    
                if (data.feedback && !isGreeting(userMessage)) {
                    previousAnswers.push(data.answer);
                    addFeedbackButtons(messageElement, userMessage, data.answer);
                } else {
                    previousAnswers = [];
                }
    
                setTimeout(scrollToBottom, 100);
            } catch (error) {
                console.error("Error sending message:", error);
                loadingMessage.remove();
                prependMessage("Произошла ошибка при генерации ответа. Пожалуйста, попробуйте позже.", 'bot-message', '{{ url_for('static', filename='bot_icon.png') }}');
            }
        }
    }
    
    function displayButtons(buttons) {
        const buttonsContainer = document.getElementById('buttons-container');
        buttonsContainer.innerHTML = '';
        buttons.forEach(button => {
            const link = document.createElement('button');
            link.textContent = button.question;
            link.classList.add('chat-button');
            link.addEventListener('click', () => sendMessage(button.question));
            buttonsContainer.appendChild(link);
        });
    }
    
    function clearButtonsContainer() {
        const buttonsContainer = document.getElementById('buttons-container');
        buttonsContainer.innerHTML = '';
    }
    
    // Добавьте эти строки после объявления функции sendMessage
    sendButton.addEventListener('click', () => sendMessage());
    inputField.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') sendMessage();
    });

    function createLinkButton(link) {
        const button = document.createElement('button');
        button.textContent = link.question.replace('?', '').trim();
        
        if (link.type === 'fork') {
            button.classList.add('fork-button');
        } else if (isValidPageNumber(link.url)) {
            button.classList.add('pdf-page-button'); // Добавляем класс для кнопок с номерами страниц
        } else {
            button.classList.add('link-button');
        }

        button.addEventListener('click', function(event) {
            event.preventDefault();
            event.stopPropagation();
            handleLinkButtonClick(link);
        });

        return button;
    }

    
    async function handleLinkButtonClick(link) {
        if (link.type === 'fork') {
            await sendMessage(link.question);
        } else {
            if (isValidPageNumber(link.url)) {
                // Если URL - это число (номер страницы)
                openPdfAndGoToPage(parseInt(link.url));
            } else {
                await sendLinkQuestion(link.question, link.url);
                if (link.url) {
                    window.open(link.url, '_blank');
                }
            }
        }
    }
    
    function isValidPageNumber(value) {
        // Удаляем пробелы в начале и конце строки
        value = value.toString().trim();
        // Проверяем, что строка состоит только из цифр
        return /^\d+$/.test(value);
    }

    function createLinksContainer(links, questionText) {
        const newLinksContainer = document.createElement('div');
        newLinksContainer.classList.add('links-container', 'fade-in');
    
        // Присваиваем числовые значения типам кнопок
        const typeOrder = {
            'fork': 1,
            'pdf': 2,
            'link': 3
        };
    
        // Создаем копию массива перед сортировкой
        const sortedLinks = [...links].sort((a, b) => {
            return typeOrder[a.type] - typeOrder[b.type];
        });
    
        const visibleLinks = sortedLinks.slice(0, 5);
        const hiddenLinks = sortedLinks.slice(5);
    
        visibleLinks.forEach(link => {
            if (link.question !== questionText) {
                newLinksContainer.appendChild(createLinkButton(link));
            }
        });
    
        if (hiddenLinks.length > 0) {
            const showMoreContainer = document.createElement('div');
            showMoreContainer.classList.add('show-more-container', 'fade-in');
            showMoreContainer.textContent = `Показать больше (${hiddenLinks.length})`;
            showMoreContainer.addEventListener('click', () => {
                hiddenLinks.forEach(link => {
                    if (link.question !== questionText) {
                        newLinksContainer.appendChild(createLinkButton(link));
                    }
                });
                showMoreContainer.remove();
            });
            newLinksContainer.appendChild(showMoreContainer);
        }
    
        return newLinksContainer;
    }

    function clearLinksContainer() {
        const linksContainer = document.querySelector('.links-container');
        if (linksContainer) linksContainer.remove();
    }

    function addFeedbackButtons(messageElement, question, answer) {
        const feedbackContainer = document.createElement('div');
        feedbackContainer.classList.add('feedback-container');

        const likeButton = createFeedbackButton('like', '{{ url_for('static', filename='like_1.png') }}', '{{ url_for('static', filename='like_2.png') }}');
        const dislikeButton = createFeedbackButton('dislike', '{{ url_for('static', filename='dislike_1.png') }}', '{{ url_for('static', filename='dislike_2.png') }}');

        feedbackContainer.appendChild(likeButton);
        feedbackContainer.appendChild(dislikeButton);
        messageElement.appendChild(feedbackContainer);

        removeOldFeedbackButtons();
    }

    function createFeedbackButton(feedbackType, initialImage, activeImage) {
        const button = document.createElement('button');
        button.classList.add('feedback-button', `${feedbackType}-button`);
        const image = document.createElement('img');
        image.src = initialImage;
        button.appendChild(image);
        button.addEventListener('click', () => {
            image.src = activeImage;
            button.classList.add('disabled');
            document.querySelector(`.${feedbackType === 'like' ? 'dislike' : 'like'}-button`).classList.add('disabled');
            sendFeedback(button.parentElement.parentElement, feedbackType);
        });
        return button;
    }

    function removeOldFeedbackButtons() {
        const messages = chatBox.querySelectorAll('.message');
        messages.forEach((msg, index) => {
            if (index !== 0 && msg.classList.contains('bot-message')) {
                const feedbackContainer = msg.querySelector('.feedback-container');
                if (feedbackContainer) feedbackContainer.remove();
            }
        });
    }

    async function sendLinkQuestion(question, url) {
        if (question !== '') {
            lastQuestion = question;
            prependMessage(question, 'user-message', '{{ url_for('static', filename='user_icon.png') }}');
    
            const loadingMessage = prependMessage('Генерация ответа...', 'loading-message');
    
            try {
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ question, previous_answers: previousAnswers })
                });
    
                const data = await response.json();
                loadingMessage.remove();
    
                const messageElement = prependMessage(data.answer, 'bot-message', '{{ url_for('static', filename='bot_icon.png') }}', data.images, data.pdf_page);
    
                clearLinksContainer();
    
                if (data.links && data.links.length > 0) {
                    const newLinksContainer = createLinksContainer(data.links, question);
                    chatBox.insertBefore(newLinksContainer, chatBox.firstChild);
                    setTimeout(scrollToBottom, 100);
                } else {
                    const noLinkContainer = document.createElement('div');
                    noLinkContainer.classList.add('links-container', 'fade-in');
                    noLinkContainer.appendChild(createLinkButton({ question, url: '' }));
                    chatBox.insertBefore(noLinkContainer, chatBox.firstChild);
                    setTimeout(scrollToBottom, 100);
                }
    
                if (data.feedback && !isGreeting(question)) {
                    previousAnswers.push(data.answer);
                    addFeedbackButtons(messageElement, question, data.answer);
                } else {
                    previousAnswers = [];
                }
            } catch (error) {
                console.error("Error sending link question:", error);
                loadingMessage.remove();
                prependMessage("Произошла ошибка при генерации ответа. Пожалуйста, попробуйте позже.", 'bot-message', '{{ url_for('static', filename='bot_icon.png') }}');
            }
        }
    }

    function prependMessage(message, className, icon, images = [], pdfPage = null) {
        message = message.replace(/_x000D_/g, '');
    
        const messageElement = document.createElement('div');
        messageElement.classList.add('message', className);
        messageElement.setAttribute('data-feedback-sent', 'false');
    
        if (icon) {
            const iconElement = document.createElement('img');
            iconElement.src = icon;
            messageElement.appendChild(iconElement);
        }
    
        const messageContent = document.createElement('div');
        messageContent.innerHTML = message;
        messageElement.appendChild(messageContent);
    
        if (pdfPage) {
            const pageLink = document.createElement('a');
            pageLink.href = '#';
            pageLink.textContent = `Страница ${pdfPage}`;
            pageLink.addEventListener('click', (e) => {
                e.preventDefault();
                openPdfAndGoToPage(pdfPage);
            });
            messageElement.appendChild(pageLink);
        }
    
        chatBox.insertBefore(messageElement, chatBox.firstChild);
        setTimeout(() => messageElement.classList.add('fade-in', 'slide-in'), 100);
        setTimeout(scrollToBottom, 100);
        return messageElement;
    }
    
    function openPdfAndGoToPage(pageNumber) {
        if (!pdfDoc) return;

        // Показываем PDF контейнер, если он скрыт
        if (pdfContainer.style.display === 'none') {
            toggleInstructionButton.click();
        }

        // Убедимся, что PDF контейнер отображается
        pdfContainer.style.display = 'block';

        // Плавная прокрутка к нужной странице
        pdfContainer.scrollTo({
            top: (pageNumber - 1) * (pdfContainer.clientHeight / pdfDoc.numPages),
            behavior: 'smooth'
        });

        // Рендерим три страницы после текущей
        const startPage = pageNumber;
        const endPage = Math.min(pageNumber + 2, pdfDoc.numPages);
        for (let i = startPage; i <= endPage; i++) {
            renderPage(i);
        }
    }

    function isGreeting(userMessage) {
        const greetings = ["привет", "здравствуй", "добрый день", "как дела", "погода", "возможности", "ты кто"];
        return greetings.some(greeting => userMessage.toLowerCase().includes(greeting));
    }

    function scrollToBottom() {
        chatBox.scrollTop = chatBox.scrollHeight;
    }

    async function sendFeedback(messageElement, feedbackType) {
        if (messageElement.getAttribute('data-feedback-sent') === 'true') return;

        const feedback = { question: lastQuestion, answer: messageElement.textContent };
        try {
            const response = await fetch(`/${feedbackType}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question: feedback.question, answer: feedback.answer })
            });

            if (!response.ok) {
                const errorData = await response.json();
                console.error(`Error sending ${feedbackType} feedback:`, errorData);
            } else {
                console.log(`${feedbackType} feedback sent successfully`);
                messageElement.setAttribute('data-feedback-sent', 'true');
            }
        } catch (error) {
            console.error(`Error sending ${feedbackType} feedback:`, error);
        }
    }

    loadSuggestions();
</script>
</body>
</html>